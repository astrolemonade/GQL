{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"GQL - Git Query Language <p>GQL is a query language with a syntax very similar to SQL with a tiny engine to perform queries on .git files instance of database files, the engine executes the query on the fly without the need to create database files or convert .git files into any other format, note that all Keywords in GQL are case-insensitive similar to SQL.</p>"},{"location":"#samples","title":"Samples","text":"<pre><code>SELECT 1\nSELECT 1 + 2\nSELECT LEN(\"Git Query Language\")\nSELECT \"One\" IN (\"One\", \"Two\", \"Three\")\nSELECT \"Git Query Language\" LIKE \"%Query%\"\n\nSELECT DISTINCT title AS tt FROM commits\nSELECT name, COUNT(name) AS commit_num FROM commits GROUP BY name ORDER BY commit_num DESC LIMIT 10\nSELECT commit_count FROM branches WHERE commit_count BETWEEN 0 .. 10\n\nSELECT * FROM refs WHERE type = \"branch\"\nSELECT * FROM refs ORDER BY type\n\nSELECT * FROM commits\nSELECT name, email FROM commits\nSELECT name, email FROM commits ORDER BY name DESC, email ASC\nSELECT name, email FROM commits WHERE name LIKE \"%gmail%\" ORDER BY name\nSELECT * FROM commits WHERE LOWER(name) = \"amrdeveloper\"\nSELECT name FROM commits GROUP By name\nSELECT name FROM commits GROUP By name having name = \"AmrDeveloper\"\n\nSELECT * FROM branches\nSELECT * FROM branches WHERE is_head = true\nSELECT name, LEN(name) FROM branches\n\nSELECT * FROM tags\nSELECT * FROM tags OFFSET 1 LIMIT 1\n</code></pre>"},{"location":"sdk/","title":"GitQL SDK","text":"<p>The architecture for GitQL designed to enable you to embedded the full engine with all required components and work with dynamic data so for example you can run the SQL query on files, API response, So this design help you to easy create a tool that can run SQL like query on any structured data such as Files, API Response, Logs, Abstract syntax tree ...etc.</p>"},{"location":"sdk/#sdk-components","title":"SDK Components","text":"Component Description Install gitql-cli CLI components like args parser, cli reporter <code>cargo install gitql-cli</code> gitql-ast structures components such as AST, functions <code>cargo install gitql-ast</code> gitql-parser Parser and Type checker components <code>cargo install gitql-parser</code> gitql-engine Execution engine component <code>cargo install gitql-engine</code> <p>To use the GitQL SDK with different data you need to define two things <code>Schema</code> and <code>DataProvider</code> for the data so the SDK know how to load and validate the data.</p> <p>Note: Most of the times you may don't need to use the <code>gitql-cli</code> component and write your own args parser using <code>clap</code> or implement your own code.</p>"},{"location":"sdk/#define-your-own-schema","title":"Define your own Schema","text":"<p>To allow using GitQL SDK on different data you need to define the data schema so it can be used to validate the symbols and types on the query.</p> <p>The Schema is just a 2 maps</p> <p>The tables Fields names map is used to define which tables we expect and what fields each table contains for example for Files schema.</p> <pre><code>use lazy_static::lazy_static;\nuse std::collections::HashMap;\n\nlazy_static! {\n    pub static ref TABLES_FIELDS_TYPES: HashMap&lt;&amp;'static str, DataType&gt; = {\n        let mut map = HashMap::new();\n        map.insert(\"path\", DataType::Text);\n        map.insert(\"parent\", DataType::Text);\n        map.insert(\"extension\", DataType::Text);\n        map.insert(\"size\", DataType::Integer);\n        map\n    };\n}\n</code></pre> <p>The other map is for types so it define the type of each field on the schema for example for Files schema.</p> <pre><code>use gitql_ast::types::DataType;\nuse lazy_static::lazy_static;\nuse std::collections::HashMap;\n\nlazy_static! {\n    pub static ref TABLES_FIELDS_NAMES: HashMap&lt;&amp;'static str, Vec&lt;&amp;'static str&gt;&gt; = {\n        let mut map = HashMap::new();\n        map.insert(\"files\", vec![\"path\", \"parent\", \"extension\", \"size\"]);\n        map\n    };\n}\n</code></pre> <p>Then create the Schema object from the two maps</p> <pre><code>use gitql_ast::schema::Schema;\n\nlet schema = Schema {\n    tables_fields_names: TABLES_FIELDS_NAMES.to_owned(),\n    tables_fields_types: TABLES_FIELDS_TYPES.to_owned(),\n};\n</code></pre>"},{"location":"sdk/#define-your-own-dataprovider","title":"Define your own DataProvider","text":"<p>The DataProvider is a simple component that used to load any kind of data and map them to the GitQLObject so the engine can deal with it, you should implement the <code>DataProvider</code> trait for your data and can work with one or more data sources but make sure that your schema matches the data, for example to work with Files.</p> <pre><code>use std::path::Path;\n\nuse gitql_ast::environment::Environment;\nuse gitql_ast::expression::Expression;\nuse gitql_ast::expression::SymbolExpression;\nuse gitql_ast::object::GitQLObject;\nuse gitql_ast::object::Group;\nuse gitql_ast::object::Row;\nuse gitql_ast::value::Value;\nuse gitql_engine::data_provider::DataProvider;\nuse gitql_engine::engine_evaluator::evaluate_expression;\n\npub struct FileDataProvider {\n    pub base_path: String,\n}\n\nimpl FileDataProvider {\n    pub fn new(base_path: String) -&gt; Self {\n        Self { base_path }\n    }\n}\n\nimpl DataProvider for FileDataProvider {\n    fn provide(\n        &amp;self,\n        env: &amp;mut Environment,\n        _table: &amp;str,\n        fields_names: &amp;[String],\n        titles: &amp;[String],\n        fields_values: &amp;[Box&lt;dyn Expression&gt;],\n    ) -&gt; GitQLObject {\n        let files = traverse_file_path(&amp;self.base_path);\n        let mut groups: Vec&lt;Group&gt; = vec![];\n        let mut rows: Vec&lt;Row&gt; = vec![];\n\n        let names_len = fields_names.len() as i64;\n        let values_len = fields_values.len() as i64;\n        let padding = names_len - values_len;\n\n        for file in files {\n            let mut values: Vec&lt;Value&gt; = vec![];\n\n            for index in 0..names_len {\n                let field_name = &amp;fields_names[index as usize];\n\n                if (index - padding) &gt;= 0 {\n                    let value = &amp;fields_values[(index - padding) as usize];\n                    if value.as_any().downcast_ref::&lt;SymbolExpression&gt;().is_none() {\n                        let evaluated = evaluate_expression(env, value, titles, &amp;values);\n                        values.push(evaluated.unwrap_or(Value::Null));\n                        continue;\n                    }\n                }\n\n                if field_name == \"path\" {\n                    let path = Path::new(&amp;file);\n                    let file_path_string = path.to_str().unwrap_or(\"\");\n                    values.push(Value::Text(file_path_string.to_string()));\n                    continue;\n                }\n\n                if field_name == \"parent\" {\n                    let path = Path::new(&amp;file);\n                    let parent_path = if let Some(parent) = path.parent() {\n                        parent.to_str().unwrap_or(\"\")\n                    } else {\n                        \"\"\n                    };\n                    values.push(Value::Text(parent_path.to_string()));\n                    continue;\n                }\n\n                if field_name == \"extension\" {\n                    let path = Path::new(&amp;file);\n                    let extension = path.extension().and_then(|ext| ext.to_str()).unwrap_or(\"\");\n                    values.push(Value::Text(extension.to_string()));\n                    continue;\n                }\n\n                if field_name == \"size\" {\n                    let file_size = if let Ok(meta_data) = std::fs::metadata(&amp;file) {\n                        meta_data.len() as i64\n                    } else {\n                        0\n                    };\n                    values.push(Value::Integer(file_size));\n                    continue;\n                }\n\n                values.push(Value::Null);\n            }\n\n            rows.push(Row { values });\n        }\n\n        groups.push(Group { rows });\n        GitQLObject {\n            titles: titles.to_vec(),\n            groups,\n        }\n    }\n}\n\nfn traverse_file_path(dir_path: &amp;String) -&gt; Vec&lt;String&gt; {\n    let mut file_paths = Vec::new();\n    let mut stack: Vec&lt;String&gt; = vec![dir_path.clone()];\n\n    while let Some(path) = stack.pop() {\n        if let Ok(entries) = std::fs::read_dir(&amp;path) {\n            for entry in entries {\n                if let Ok(entry) = entry {\n                    let file_type = entry.file_type().unwrap();\n                    let subpath = entry.path();\n\n                    if file_type.is_dir() {\n                        stack.push(subpath.to_str().unwrap_or(\"\").to_string());\n                    } else {\n                        if let Some(file_path) = subpath.to_str() {\n                            file_paths.push(file_path.to_string());\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    file_paths\n}\n</code></pre> <p>Now you have the Schema and DataProvider it's time to config the other SDK Components.</p> <p>Note: that the path and query can be come from command line arguments or passed by your GUI app.</p> <pre><code>let base_path = ...;\nlet query = ...;\n\nlet schema = Schema {\n    tables_fields_names: TABLES_FIELDS_NAMES.to_owned(),\n    tables_fields_types: TABLES_FIELDS_TYPES.to_owned(),\n};\n\nlet mut env = Environment::new(schema);\n\nlet mut reporter = DiagnosticReporter::default();\nlet tokenizer_result = tokenizer::tokenize(query.to_owned());\nlet tokens = tokenizer_result.ok().unwrap();\nif tokens.is_empty() {\n    return;\n}\n\nlet parser_result = parser::parse_gql(tokens, &amp;mut env);\nif parser_result.is_err() {\n    let diagnostic = parser_result.err().unwrap();\n    reporter.report_diagnostic(&amp;query, *diagnostic);\n    return;\n}\n\nlet query_node = parser_result.ok().unwrap();\nlet provider: Box&lt;dyn DataProvider&gt; = Box::new(FileDataProvider::new(base_path.to_owned()));\nlet evaluation_result = engine::evaluate(&amp;mut env, &amp;provider, query_node);\n\n// Report Runtime exceptions if they exists\nif evaluation_result.is_err() {\n    reporter.report_diagnostic(\n        &amp;query,\n        Diagnostic::exception(&amp;evaluation_result.err().unwrap()),\n    );\n    return;\n}\n\n// Render the result only if they are selected groups not any other statement\nlet engine_result = evaluation_result.ok().unwrap();\nif let SelectedGroups(mut groups, hidden_selection) = engine_result {\n    match format {\n        OutputFormat::Render =&gt; {\n            render::render_objects(&amp;mut groups, &amp;hidden_selection, pagination, page_size);\n        }\n        OutputFormat::JSON =&gt; {\n            let mut indexes = vec![];\n            for (index, title) in groups.titles.iter().enumerate() {\n                if hidden_selection.contains(title) {\n                    indexes.insert(0, index);\n                }\n            }\n\n            if groups.len() &gt; 1 {\n                groups.flat()\n            }\n\n            for index in indexes {\n                groups.titles.remove(index);\n                for row in &amp;mut groups.groups[0].rows {\n                    row.values.remove(index);\n                }\n            }\n\n            if let Ok(json) = groups.as_json() {\n                println!(\"{}\", json);\n            }\n        }\n        OutputFormat::CSV =&gt; {\n            let mut indexes = vec![];\n            for (index, title) in groups.titles.iter().enumerate() {\n                if hidden_selection.contains(title) {\n                    indexes.insert(0, index);\n                }\n            }\n\n            if groups.len() &gt; 1 {\n                groups.flat()\n            }\n\n            for index in indexes {\n                groups.titles.remove(index);\n\n                for row in &amp;mut groups.groups[0].rows {\n                    row.values.remove(index);\n                }\n            }\n\n            if let Ok(csv) = groups.as_csv() {\n                println!(\"{}\", csv);\n            }\n        }\n    }\n}\n</code></pre> <p>Note: render the result as table, json or csv not the only option you can send them using API or send them to GUI.</p>"},{"location":"setup/","title":"Setup","text":""},{"location":"setup/#install-from-package-managers","title":"Install from Package managers","text":""},{"location":"setup/#cargoio","title":"Cargo.io","text":"<pre><code>cargo install gitql\n</code></pre> <p>Note that from version <code>0.10.0</code> installing from Cargo require <code>Cmake</code> to be installed so it can build the dependencies.</p>"},{"location":"setup/#winget-on-windows","title":"Winget on Windows","text":"<pre><code>winget install gitql\n</code></pre>"},{"location":"setup/#scoop-on-windows","title":"Scoop on Windows","text":"<pre><code>scoop install gitql\n</code></pre>"},{"location":"setup/#on-single-repository","title":"On Single repository","text":"<p>gitql"},{"location":"setup/#on-multi-repositories","title":"On multi repositories","text":"<p>gitql --repo   ...etc"},{"location":"setup/#or","title":"Or","text":"<p>gitql -r   ...etc <pre><code>## Download Binaries\n\nFrom Github repository page you can download the right executable for your OS and Arch from the latest release\n\n## Build GQL From source code\n\n```sh\ngit clone https://github.com/amrdeveloper/gql\ncd gql\n\n# On Single repository\ncargo run &lt;repository_path&gt;\n\n# On multi repositories\ncargo run -- --repo &lt;repository_path&gt; &lt;repository_path&gt; ...etc\ncargo run -- -r &lt;repository_path&gt; &lt;repository_path&gt; ...etc\n</code></pre>"},{"location":"setup/#command-line-arguments","title":"Command line arguments","text":"<pre><code>Usage: gitql [OPTIONS]\n\nOptions:\n-r,  --repos &lt;REPOS&gt;        Path for local repositories to run query on\n-q,  --query &lt;GQL Query&gt;    GitQL query to run on selected repositories\n-p,  --pagination           Enable print result with pagination\n-ps, --pagesize             Set pagination page size [default: 10]\n-o,  --output               Set output format [render, json, csv]\n-a,  --analysis             Print Query analysis\n-h,  --help                 Print GitQL help\n-v,  --version              Print GitQL Current Version\n</code></pre>"},{"location":"expression/binary/","title":"Binary","text":"<p>A binary expression contains two operands separated by one operator</p>"},{"location":"expression/binary/#arithmetic-expression","title":"Arithmetic Expression","text":"<p>Used to perform arithmetic operators on number types.</p> <ul> <li><code>+</code> Addition.</li> <li><code>-</code> Subtraction.</li> <li><code>*</code> Multiplication.</li> <li><code>/</code> Division.</li> <li><code>%</code> Modulus.</li> </ul>"},{"location":"expression/binary/#comparison-expression","title":"Comparison Expression","text":"<ul> <li><code>=</code> used to check if two values are equals.</li> <li><code>!=</code> or <code>&lt;&gt;</code> used to check if two values are not equals.</li> <li><code>&gt;</code> used to check value greater than other value.</li> <li><code>&gt;=</code> used to check if value is greater than or equals than other value</li> <li><code>&lt;</code> used to check if value is less than than other value.</li> <li><code>&lt;=</code> used to check if value is less than or equals than other value.</li> <li><code>&lt;=&gt;</code> Returns 1 rather than NULL if both operands are NULL, and 0 rather than NULL if one operand is NULL.</li> </ul>"},{"location":"expression/binary/#like-expression","title":"Like Expression","text":"<p>The <code>LIKE</code> operator is used for searching for a specified pattern in a string.</p> <pre><code>SELECT \"Git Query Language\" LIKE \"G%\"\nSELECT \"Git Query Language\" LIKE \"%e\"\nSELECT \"Git Query Language\" LIKE \"%Query%\"\nSELECT \"10 usd\" LIKE \"[0-9]* usd\"\n</code></pre>"},{"location":"expression/binary/#glob-expression","title":"Glob Expression","text":"<p>The <code>GLOB</code> operator is similar to <code>LIKE</code> but uses the Unix file globing syntax for its wildcards. Also, <code>GLOB</code> is case sensitive, unlike <code>LIKE</code>.</p> <pre><code>SELECT \"Git Query Language\" GLOB \"Git*\"\n</code></pre>"},{"location":"expression/binary/#logical-expressions","title":"Logical Expressions","text":"<ul> <li><code>||</code> or <code>or</code>: used to calculate logical or between two booleans,</li> <li><code>&amp;&amp;</code> or <code>and</code>: used to calculate logical and between two booleans,</li> <li><code>^</code> or <code>xor</code>: used to calculate logical xor between two booleans,</li> </ul>"},{"location":"expression/binary/#bitwise-expressions","title":"Bitwise Expressions","text":"<ul> <li><code>|</code>: used to calculate bitwise or between two numbers,</li> <li><code>&amp;</code>: used to calculate bitwise and between two numbers,</li> <li><code>&lt;&lt;</code>: used to calculate bitwise right shift between two numbers,</li> <li><code>&gt;&gt;</code>: used to calculate bitwise left shift between two numbers,</li> </ul>"},{"location":"expression/binary/#between-expression","title":"Between Expression","text":"<p>Used to check if value is between range start and end included</p> <pre><code>SELECT commit_count FROM branches WHERE commit_count BETWEEN 2 .. 30000\n</code></pre>"},{"location":"expression/binary/#is-null-expression","title":"Is Null Expression","text":"<p>Returns true if value is null, can used with <code>NOT</code> keyword to return if true if not null</p> <pre><code>SELECT 1 IS NULL\nSELECT 1 IS NOT NULL\n</code></pre>"},{"location":"expression/binary/#in-expression","title":"In Expression","text":"<p>Returns true if any one or more values are equal to the argument</p> <pre><code>SELECT \"One\" IN (\"One\", \"Two\", \"Three\")\nSELECT \"One\" NOT IN (\"One\", \"Two\", \"Three\")\n</code></pre>"},{"location":"expression/binary/#regex-expression","title":"Regex Expression","text":"<p>Returns true if the string expr matches the regular expression specified by the pattern</p> <pre><code>SELECT \"a\" REGEXP \"^[a-d]\";\nSELECT \"a\" NOT REGEXP \"^[a-d]\";\n</code></pre>"},{"location":"expression/case/","title":"Case","text":"<p>Case expression is similar to Switch Expression in many languages, it's return the value of the first branch that has condition evaluated to true, if not branch found it will return the default value</p> <pre><code>SELECT name FROM branches WHERE (CASE WHEN isRemote THEN 1 ELSE 0 END) &gt; 0\n</code></pre>"},{"location":"expression/unary/","title":"Unary","text":"<p>The unary expression is an expression the prefixed with operators</p>"},{"location":"expression/unary/#prefix-unary-expression","title":"Prefix Unary Expression","text":"<ul> <li><code>!</code> takes truth to falsity and vice versa. It is typically used with boolean</li> </ul> <pre><code>SELECT * FROM branches WHERE !is_remote\nSELECT * FROM branches WHERE !is_head\n</code></pre> <ul> <li><code>-</code> negates the value of the operand.</li> </ul> <pre><code>SELECT * FROM branches WHERE commit_count &gt; -1\n</code></pre>"},{"location":"function/aggregations/","title":"Aggregations","text":"<p>An aggregate function in GQL performs a calculation on multiple values and returns a single value</p>"},{"location":"function/aggregations/#aggregation-max","title":"Aggregation <code>max</code>","text":"<p>Accept field name to calculate the maximum value of it for all elements until the current one</p> <pre><code>SELECT name, commit_count, max(commit_count) FROM branches\n</code></pre>"},{"location":"function/aggregations/#aggregation-min","title":"Aggregation <code>min</code>","text":"<p>Accept field name to calculate the minimum value of it for all elements until the current one</p> <pre><code>SELECT name, commit_count, min(commit_count) FROM branches\n</code></pre>"},{"location":"function/aggregations/#aggregation-sum","title":"Aggregation <code>sum</code>","text":"<p>The function sum() is an aggregate function that returns the sum of items in a group</p> <pre><code>SELECT name, sum(insertions) FROM diffs GROUP BY name\n</code></pre>"},{"location":"function/aggregations/#aggregation-avg","title":"Aggregation <code>avg</code>","text":"<p>The function avg() is an aggregate function that returns the average values of items in a group</p> <pre><code>SELECT name, avg(insertions) FROM commits GROUP BY name\n</code></pre>"},{"location":"function/aggregations/#aggregation-count","title":"Aggregation <code>count</code>","text":"<p>The function count() is an aggregate function that returns the number of items in a group</p> <pre><code>SELECT name, max(name) FROM commits GROUP BY name\n</code></pre>"},{"location":"function/functions/","title":"Functions","text":"<p>An function in GitQL accept one or more value and return value, note that all functions names are case-insensitive.</p>"},{"location":"function/functions/#string-functions","title":"String functions","text":"Name Parameters Return Description LOWER Text Text Return Text in lower case. UPPER Text Text Return Text in upper case. REVERSE Text Text Return a reversed string. TRIM Text Text Removes leading and trailing spaces from a string. LTRIM Text Text Removes leading spaces from a string. RTRIM Text Text Removes trailing spaces from a string. LEN Text Integer Return the length of this string. REPLICATE Text, Integer Text Return repeated a string a specified number of times. SPACE Integer Text Returns a string of the specified number of space characters. ASCII Text Integer Returns the ASCII value for the specific character. LEFT Text, Integer Text Extracts a number of characters from a string (starting from left). DATALENGTH Text Integer Returns the number of bytes used to represent an expression. CHAR Integer Text Returns the character based on the ASCII code. CHARINDEX Text, Text Integer Returns the starting position of the first occurrence of a string in another string. NCHAR Integer Text Returns the character based on the ASCII code. REPLACE Text, Text, Text Text Replaces all occurrences of a substring within a string, with a new substring. SUBSTRING Text, Integer, Integer Text Extracts some characters from a string. STUFF Text, Integer, Integer, Text Text Deletes a part of a string and then inserts another part into the string, starting at a specified position. RIGHT Text, Integer Text Extracts a number of characters from a string (starting from right). TRANSLATE Text, Text, Text, Text Returns the string from the first argument after the characters specified in the second argument are translated into the characters specified in the third argument. SOUNDEX Text Text Returns a four-character code to evaluate the similarity of two expressions. CONCAT Any, Any, ...Any Text Add several string representations of values together together. CONCAT_WS Text, Any, Any, ...Any Text Add several string representations of values together together with separate. UNICODE Text Integer Return an integer value (the Unicode value), for the first character of the input expression. STRCMP Text , Text Integer Return 0 If string1 = string2, -1 if string1 &lt; string2, this function returns -1, and 1 if string1 &gt; string2 QUOTENAME Text , Text Text Returns the string (first argument) with specified delimiters (second argument), defaulting to []"},{"location":"function/functions/#string-functions-samples","title":"String functions samples","text":"<pre><code>SELECT * FROM commits where LOWER(name) = \"amrdeveloper\"\nSELECT * FROM commits where UPPER(name) = \"AMRDEVELOPER\"\nSELECT * FROM commits where REVERSE(name) = \"repolevedrma\"\nSELECT * FROM commits where TRIM(name) = \"\"\nSELECT * FROM commits where LEN(name) &gt; 0\nSELECT * FROM commits where name = SPACE(5)\nSELECT name, ASCII(name) AS firstCharAscii FROM commits\nSELECT LEFT(\"AmrDeveloper\", 3) AS extract\nSELECT DATALENGTH(\"AmrDeveloper\") as bytelength\nSELECT CHAR(345) AS code\nSELECT CHARINDEX(\"DEV\", \"AmrDeveloper\") AS position\nSELECT REPLACE(\"ABC ABC ABC\", \"a\", \"c\") as replacedText\nSELECT name, SUBSTRING(name, 1, 5) AS extract FROM commits\nSELECT STUFF(\"GQL tutorial!\", 13, 1, \" is fun!\")\nSELECT RIGHT(\"AmrDeveloper\", 3) AS extract\nSELECT TRANSLATE(\"Amr[Dev]{eloper}\", \"[]{}\", \"()()\")\nSELECT SOUNDEX(\"AmrDeveloper\") as code\nSELECT CONCAT(\"amrdeveloper\", \".github.io\")\nSELECT CONCAT_WS(\"_\", \"Git\", \"Query\", \"Language\"); \nSELECT UNICODE(\"AmrDeveloper\")\nSELECT QUOTENAME(\"AmrDeveloper\")\nSELECT QUOTENAME(\"AmrDeveloper\", \".\")\nSELECT QUOTENAME(\"AmrDeveloper\", \"{}\")\n</code></pre>"},{"location":"function/functions/#date-functions","title":"Date functions","text":"Name Parameters Return Description Date DateTime Date Extracts the date part from a datetime expression. CURRENT_TIME Time Return current time in <code>HH:MM:SS</code> format. CURRENT_DATE Date Return current date in <code>YYYY-MM-DD</code> format. CURRENT_TIMESTAMP DateTime Return current date time in <code>YYYY-MM-DD HH:MM:SS</code> format. MAKEDATE Integer, Integer Date Create and return a date based on a year and a number of days. MAKETIME Integer, Integer, Integer Time Create and return a time value based on an hour, minute, and second value. NOW DateTime Return current date time in <code>YYYY-MM-DD HH:MM:SS</code> format. Day Date Integer Returns the index of the day (1 to 31) in the date. DAYNAME Date Text Returns the name of the day given a timestamp. MONTHNAME Date Text Returns the name of the month given a timestamp. HOUR DateTime Integer Returns the hour part of a datetime. MINUTE DateTime Integer Returns the minute part of a datetime. ISDATE Any Boolean Return TRUE if the argument type is Date. DAYOFWEEK Date Integer Returns the day of the week for a given date (a number from 1 to 7) DAYOFMONTH Date Integer Returns the day of the month for a given date (a number from 1 to 31) DAYOFYEAR Date Integer Returns the day of the year for a given date (a number from 1 to 366) WEEKOFYEAR Date Integer Returns the week number for a given date (a number from 1 to 53). QUARTER Date Integer Returns the quarter of the year for a given date value (a number from 1 to 4) YEAR Date Integer Returns the year part of the date MONTH Date Integer Returns the month part of the date (a number from 1 to 12) WEEKDAY Date Integer Returns the weekday number of the date (from 0 monday to 6 sunday) TO_DAYS Date Integer Returns the number of days between a date and date \"0000-00-00\" LAST_DAY Date Date Returns the last day of the month for a given date YEARWEEK Date Text Returns the year and week number (a number from 0 to 53) for a given date"},{"location":"function/functions/#date-functions-samples","title":"Date functions samples","text":"<pre><code>SELECT CURRENT_TIME()\nSELECT CURRENT_DATE()\nSELECT CURRENT_TIMESTAMP()\nSELECT MAKEDATE(2023, 12)\nSELECT MAKETIME(12, 59, 59)\nSELECT NOW()\nSELECT DAYNAME(CURRENT_DATE())\nSELECT MONTHNAME(CURRENT_DATE())\nSELECT HOUR(NOW())\n</code></pre>"},{"location":"function/functions/#numeric-functions","title":"Numeric Functions","text":"Name Parameters Return Description PI Float Return the value of PI. FLOOR Float Integer Returns the largest integer value that is smaller than or equal to a number. ROUND Float, Integer? Float Returns a number rounded to a specified number of decimal places. SQUARE Integer Integer Returns the square of an integer value. ABS Number Number Returns the absolute value of an integer value. SIN Float Float Returns the sine of a number. ASIN Float Float Returns the arc sine of a number. COS FLOAT FLOAT Returns the cosine of a number. ACOS FLOAT FLOAT Returns the arc cosine of a number. TAN FLOAT FLOAT Returns the tangent of a number. ATAN FLOAT FLOAT Returns the arc tangent of a number. ATN2 FLOAT, FLOAT FLOAT Returns the arc tangent of two values. SIGN Number Integer Returns the sign of a number. MOD Integer, Integer Integer Returns the remainder of a number divided by another number. RAND Float? Float Returns a random number between 0 (inclusive) and 1 (exclusive)."},{"location":"function/functions/#numeric-functions-samples","title":"Numeric functions samples","text":"<pre><code>SELECT PI()\nSELECT FLOOR(1.6)\nSELECT ROUND(1.5), ROUND(135.375, 2), ROUND(345.156, 0)\nSELECT SQUARE(64)\nSELECT ABS(-1)\nSELECT SIN(2.0)\nSELECT SIN(2)\nSELECT ATN2(0.50, 1.0)\nSELECT MOD(25, 5)\nSELECT RAND(6);\nSELECT RAND() * (10-5) + 5; \n</code></pre>"},{"location":"function/functions/#general-functions","title":"General functions","text":"Name Parameters Return Description ISNULL ANY Boolean Return TRUE if the argument type is null. ISNUMERIC ANY Boolean Return TRUE if the argument type is number. TYPEOF ANY Text Return the argument type name. GREATEST ANY, Any, ...Any Any Return the greatest value from list of values LEAST ANY, Any, ...Any Any Return the smallest value from list of values"},{"location":"function/functions/#general-functions-samples","title":"General functions samples","text":"<pre><code>SELECT ISNULL(null), ISNULL(1)\nSELECT ISNUMERIC(null), ISNUMERIC(1), ISNUMERIC(1.1), ISNUMERIC(false)\nSELECT TYPEOF(\"\"), TYPEOF(1), TYPEOF(null)\nSELECT GREATEST(1, 2, 3, 4)\nSELECT LEAST(1, 2, 3, 4)\n</code></pre>"},{"location":"function/functions/#regex-functions","title":"Regex functions","text":"Name Parameters Return Description REGEXP_INSTR Text, Text Integer Return starting index of substring matching regular expression. REGEXP_LIKE Text, Text Bool Returns true if the string expr matches the regular expression specified by the pattern. REGEXP_REPLACE Text, Text, Text Text Returns the input after replacing pattern with new content. REGEXP_SUBSTR Text, Text Text Returns substring matching regular expression ."},{"location":"function/functions/#regex-functions-samples","title":"Regex functions samples","text":"<pre><code>SELECT REGEXP_INSTR(\"dog cat dog\", \"dog\");\nSELECT REGEXP_LIKE(\"a\", \"^[a-d]\");\nSELECT REGEXP_REPLACE(\"a b c\", \"b\", \"X\");\nSELECT REGEXP_SUBSTR(\"abc def ghi\", \"[a-z]+\");\n</code></pre>"},{"location":"statement/group_by/","title":"Group by","text":"<p>The <code>GROUP BY</code> statement groups rows that have the same values into summary rows, like \"find the number of commits for each username or email\".</p> <pre><code>SELECT * FROM commits GROUP BY name\n</code></pre>"},{"location":"statement/having/","title":"Having","text":"<p>The <code>HAVING</code> statement is very similar to <code>WHERE</code> expect that it evaluated after the <code>GROUP BY</code> statement</p> <pre><code>SELECT * FROM commits GROUP BY name HAVING name = \"AmrDeveloper\"\nSELECT * FROM branches GROUP BY name HAVING is_head = \"true\"\n</code></pre>"},{"location":"statement/limit_and_offset/","title":"Limit & Offset","text":"<p>The <code>LIMIT</code> statement used to limit the number of end result</p> <pre><code>SELECT * FROM commits LIMIT 10\nSELECT * FROM branches LIMIT 15\n</code></pre> <p>The <code>OFFSET</code> statement specifies how many rows to skip at the beginning of the result set</p> <pre><code>SELECT * FROM commits OFFSET 10\nSELECT * FROM branches OFFSET 15\n</code></pre> <p>You can mix the offset and limit statements</p> <pre><code>SELECT * FROM commits OFFSET 10 LIMIT 10\nSELECT * FROM branches OFFSET 15 LIMIT 15\n</code></pre>"},{"location":"statement/order_by/","title":"Order by","text":"<p>The <code>ORDER BY</code> Statement used to order the result-set in ascending or descending order by one or more arguments.</p> <pre><code>SELECT name, email FROM commits ORDER BY name\nSELECT name, email FROM commits ORDER BY name, email\nSELECT name, email FROM commits ORDER BY email, commit_id ASC\nSELECT name, email FROM commits ORDER BY name DESC\nSELECT name, email FROM commits ORDER BY name, LEN(name)\nSELECT name, email FROM commits ORDER BY (cASE WHEN (email contains \"gmail\") THEN 1 ELSE 0 END) DESC\n</code></pre>"},{"location":"statement/select/","title":"Select","text":"<p>The <code>SELECT</code> statement is used to query data from a single table</p> <p>For example to select all fields from commits table.</p> <pre><code>SELECT * FROM commits\n</code></pre> <p>Or Selecting just title and message</p> <pre><code>SELECT title message FROM commits\n</code></pre> <p>You can use Aggregation function in the select statement to perform function on all data until the current one</p> <pre><code>SELECT count(name) FROM commits\n</code></pre> <p>You can alias the column name only in this query by using <code>as</code> keyword for example</p> <pre><code>SELECT title as tt FROM commits\nSELECT name, commit_count, max(commit_count) AS max_count message FROM branches\n</code></pre> <p>You can select unique rows only using the <code>distinct</code> keyword for example,</p> <pre><code>SELECT DISTINCT title AS tt FROM commits\n</code></pre>"},{"location":"statement/variables/","title":"Variables","text":"<p>GitQL has support for global variables with syntax inspired by MySQL</p>"},{"location":"statement/variables/#declare-variable-with-value","title":"Declare variable with value","text":"<pre><code>SET @one = 1\nSET @STRING = \"GitQL\"\n</code></pre>"},{"location":"statement/variables/#use-the-variable","title":"Use the variable","text":"<p>You can use the variable like any other symbol using the name</p> <pre><code>SELECT @one\n</code></pre>"},{"location":"statement/where/","title":"Where","text":"<p>The <code>WHERE</code> statement is used to filter the data by one or more conditions</p> <p>For example to select all commits for a specific username</p> <pre><code>SELECT * FROM commits where name = \"AmrDeveloper\"\nSELECT * FROM commits WHERE name contains \"gmail\"\nSELECT * FROM branches WHERE is_head = \"true\"\nSELECT * FROM branches WHERE name ends_with \"master\"\nSELECT * FROM branches WHERE name contains \"origin\"\n</code></pre> <p>You can add Unary and Binary expressions, but you can use Aggregation functions inside the Where statement, because it calculated after the group by statement.</p>"},{"location":"structure/tables/","title":"Tables","text":""},{"location":"structure/tables/#gql-tables","title":"GQL Tables","text":"<p>You can see list of all tables directly in the repl using</p> <pre><code>show tables\n</code></pre>"},{"location":"structure/tables/#references-table","title":"References table","text":"Name Type Description name Text Reference name full_name Text Reference full name type Text Reference type repo Text Repository full path"},{"location":"structure/tables/#commits-table","title":"Commits table","text":"Name Type Description commit_id Text Commit id title Text Commit title message Text Commit full message name Text Author name email Text Author email datetime Date Commit date time repo Text Repository full path"},{"location":"structure/tables/#diffs-table","title":"Diffs table","text":"Name Type Description commit_id Text Commit id name Text Author name email Text Author email insertions Number Number of inserted lines deletions Number Number of deleted lines files_changed Number Number of file changed repo Text Repository full path"},{"location":"structure/tables/#branches-table","title":"Branches table","text":"Name Type Description name Text Branch name commit_count Number Number of commits in this branch is_head Bool Is the head branch is_remote Bool Is a remote branch repo Text Repository full path"},{"location":"structure/tables/#tags-table","title":"Tags table","text":"Name Type Description name Text Tag name repo Text Repository full path"},{"location":"structure/types/","title":"Types","text":"<p>The GQL has a basic type system with only four types to be used for safe functions call and expressions.</p>"},{"location":"structure/types/#types-informations","title":"Types information's","text":"Name Description Any Used to represent Any data type Text Used to represent string literal Integer Used to represent integers Float Used to represent floats Boolean Used to represent boolean value Date Used to represent date Time Used to represent time DateTime Used to represent date &amp; time Variant(types) Used to represent a variant of types Optional(type) Used to represent a optional type or none Varargs(type) Used to represent a variable arguments type"}]}